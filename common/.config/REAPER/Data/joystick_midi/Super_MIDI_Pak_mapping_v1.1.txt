//////////////////////////////////////////////
// Changelog:                               //
// v1.0 (16-12-2025)                        //
//  - buttons/axis/pov implementation       //
//  - minor/Major tuning with select/start  //
// v1.1 (12-02-2026)                        //
//  - octave, tuning & MIDI ch selection    //
//  - echo & portamento toggles per channel //
//  - minor pitch shift = 0.5, Major = 1    //
//////////////////////////////////////////////

///////////////////////////////////////
//      Super MIDI Pak mapping:      //
//             C4 Major              //
//            3       1              //
//          7   6   4   5            //
//            2       8              //
//                                   //
// Additions:                        //
//   Select + L: -1 octave           //
//   Select + R: +1 octave           //
//   Select + X: minor scale         //
//   Select + Y: Major scale         //
//   Start + L: -1 MIDI channel      //
//   Start + R: +1 MIDI channel      //
//   Start + X: CC echo toggle       //
//   Start + Y: CC portamento toggle //
///////////////////////////////////////

!did_init ? (
  did_init = 1;

  // Controller mapping:
  A =  0x0002;
  B =  0x0001;
  X =  0x0008;
  Y =  0x0004;
  L =  0x0010;
  R =  0x0020;
  Sl = 0x0040;
  St = 0x0080;
  // Hardcoded:
  //   axis0: left (-1), right (1)
  //   axis1: up (-1),   down (1)
  //   pov0:  up (0), right (90), down (180), left (270)

  // Number of halfsteps per scale degree:
  // Major tuning      Minor tuning
  deg[1] = 0;          deg[9]  = 0;
  deg[2] = 2;          deg[10] = 2;
  deg[3] = 4;          deg[11] = 3;
  deg[4] = 5;          deg[12] = 5;
  deg[5] = 7;          deg[13] = 7;
  deg[6] = 9;          deg[14] = 8;
  deg[7] = 11;         deg[15] = 10;
  deg[8] = 12;         deg[16] = 12;

  // Do not change the following:

  pov_map = deg + 17; // Manually aligning array pointer after previous array
  pov_map[0] = deg[3];
  pov_map[1] = deg[6];
  pov_map[2] = deg[2];
  pov_map[3] = deg[7];

  // bool for each MIDI channel
  echo_flags = pov_map + 4;
  portamento_flags = echo_flags + 16;
  i = 0;
  loop(16,
    echo_flags[i] = 0;
    portamento_flags[i] = 0;
    i += 1;
  );

  midi_ch = 0; // Indexing with [0-15], maps to MIDI channels [1-16]
  tonic = 60;  // Base note, C4.
  scale_offset = 0;

  // Pitch shift CC values: ([0, 16383], 14bits centered at 8192)
  pitch_shift_up = 16383;
  pitch_shift_down = 0;

  prev_buttons = buttons;
  numaxis ? (
    prev_axis0 = axis(0);
    prev_axis1 = axis(1);
  );
  numpov ? prev_pov0 = pov0;
);



function cancel_all_inputs() (
  this.i = 1;
  loop(8, 
    event(0x80 + midi_ch, tonic + deg[this.i + scale_offset], 127);
    this.i += 1;
  );
);

prev_buttons != buttons ? (
  // Select modifier key pressed
  buttons & Sl && !(buttons & St) ? (
    buttons & L && !(prev_buttons & L) ? (
      tonic - 12 >= 0 ? (
        cancel_all_inputs();
        tonic -= 12;
      );
    );
    buttons & R && !(prev_buttons & R) ? (
      tonic + 12 <= 127 ? (
        cancel_all_inputs();
        tonic += 12;
      );
    );
    buttons & X && !(prev_buttons & X) ? ( // Major
      cancel_all_inputs();
      pitch_shift_up = 16383;
      pitch_shift_down = 0;
      scale_offset = 0;
      pov_map[0] = deg[3 + scale_offset];
      pov_map[1] = deg[6 + scale_offset];
      pov_map[2] = deg[2 + scale_offset];
      pov_map[3] = deg[7 + scale_offset];
    );
    buttons & Y && !(prev_buttons & Y) ? ( // minor
      cancel_all_inputs();
      pitch_shift_up = 12287;
      pitch_shift_down = 4095;
      scale_offset = 8;
      pov_map[0] = deg[3 + scale_offset];
      pov_map[1] = deg[6 + scale_offset];
      pov_map[2] = deg[2 + scale_offset];
      pov_map[3] = deg[7 + scale_offset];
    );

  // Start modifier key pressed
  ) : buttons & St && !(buttons & Sl) ? (
    buttons & L && !(prev_buttons & L) ? (
      midi_ch - 1 >= 0 ? (
        cancel_all_inputs();
        midi_ch -= 1;
      );
    );
    buttons & R && !(prev_buttons & R) ? (
      midi_ch + 1 <= 15 ? (
        cancel_all_inputs();
        midi_ch += 1;
      );
    );
    buttons & X && !(prev_buttons & X) ? (
      echo_flags[midi_ch] = echo_flags[midi_ch] == 0 ? 127 : 0;
      event(0xB0 + midi_ch, 91, echo_flags[midi_ch]);  // CC event 91 = reverb level (GS)
    );
    buttons & Y && !(prev_buttons & Y) ? (
      portamento_flags[midi_ch] = portamento_flags[midi_ch] == 0 ? 127 : 0;
      event(0xB0 + midi_ch, 65, portamento_flags[midi_ch]);  // CC event 65 = portamento (GS)
    );

  // No modifier key pressed
  ) : (
    buttons & A != prev_buttons & A ? event((buttons & A ? 0x90 : 0x80) + midi_ch, tonic + deg[5 + scale_offset], 127);
    buttons & B != prev_buttons & B ? event((buttons & B ? 0x90 : 0x80) + midi_ch, tonic + deg[8 + scale_offset], 127);
    buttons & X != prev_buttons & X ? event((buttons & X ? 0x90 : 0x80) + midi_ch, tonic + deg[1 + scale_offset], 127);
    buttons & Y != prev_buttons & Y ? event((buttons & Y ? 0x90 : 0x80) + midi_ch, tonic + deg[4 + scale_offset], 127);
    buttons & L != prev_buttons & L ? buttons & L ? event(0xe0 + midi_ch, pitch_shift_up&127,   (pitch_shift_up/128)|0)   : event(0xe0 + midi_ch, 8192&127, (8192/128)|0);
    buttons & R != prev_buttons & R ? buttons & R ? event(0xe0 + midi_ch, pitch_shift_down&127, (pitch_shift_down/128)|0) : event(0xe0 + midi_ch, 8192&127, (8192/128)|0);
  );

  prev_buttons = buttons;
);

numaxis ? (
  prev_axis0 != axis(0) ? (
    // neutral
    abs(axis(0)) < 0.001 ?  (
      axis0_active ? (
        axis0_active = 0;
        event(0x80 + midi_ch, prev_axis0 > 0.999 ? tonic + deg[6 + scale_offset] : tonic + deg[7 + scale_offset], 127);
      );
    ) : (
      !axis0_active ? (
        axis0_active = 1;                                            // right : left
        event(0x90 + midi_ch, axis(0) > 0.999 ? tonic + deg[6 + scale_offset] : tonic + deg[7 + scale_offset], 127);
      );
    );

    prev_axis0 = axis(0);
  );

  prev_axis1 != axis(1) ? (
    // neutral
    abs(axis(1)) < 0.001 ?  (
      axis1_active ? (
        axis1_active = 0;
        event(0x80 + midi_ch, prev_axis1 > 0.999 ? tonic + deg[2 + scale_offset] : tonic + deg[3 + scale_offset], 127);
      );
    ) : (
      !axis1_active ? (
        axis1_active = 1;                                             // down : up
        event(0x90 + midi_ch, axis(1) > 0.999 ? tonic + deg[2 + scale_offset] : tonic + deg[3 + scale_offset], 127);
      );
    );

    prev_axis1 = axis(1);
  );
);

numpov ? (
  pov0 = pov(0) / 90;
  prev_pov0 != pov0 ? (
    // Total release (pov(0) == 655.35)
    pov0 > 4 ? (
      // Single direction release
      prev_pov0 - floor(prev_pov0) == 0 ? (
        event(0x80 + midi_ch, tonic + pov_map[prev_pov0], 127);

      // Two directions release
      ) : (
        event(0x80 + midi_ch, tonic + pov_map[                       prev_pov0 - 0.5], 127);
        event(0x80 + midi_ch, tonic + pov_map[prev_pov0 == 3.5 ? 0 : prev_pov0 + 0.5], 127); // Special case: wraparound 360<->0
      );

    ) : abs(pov0 - prev_pov0) == 0.5 ? (
      // Adjacent direction released
      pov0 - floor(pov0) == 0 ? (
        clockwise_quarter = (pov0 + (pov0 - prev_pov0 < 0 ? 1 : -1));
        event(0x80 + midi_ch, tonic + pov_map[clockwise_quarter == 4 ? 0 : clockwise_quarter], 127);
      // Adjacent direction pressed
      ) : (
        clockwise_quarter = (pov0 + (pov0 - prev_pov0 < 0 ? -0.5 : 0.5));
        event(0x90 + midi_ch, tonic + pov_map[clockwise_quarter == 4 ? 0 : clockwise_quarter], 127);
      );

    // Adjacent direction, special case: wraparound 360<->0
    ) : abs(pov0 - prev_pov0) == 3.5 ? (
      event((pov0 - floor(pov0) == 0 ? 0x80 : 0x90) + midi_ch, tonic + pov_map[3], 127);

    // Single direction press
    ) : pov0 - floor(pov0) == 0 ? (
      event(0x90 + midi_ch, tonic + pov_map[pov0], 127);

    // Two directions presses
    ) : pov0 - floor(pov0) == 0.5 ? (
      event(0x90 + midi_ch, tonic + pov_map[                  pov0 - 0.5], 127);
      event(0x90 + midi_ch, tonic + pov_map[pov0 == 3.5 ? 0 : pov0 + 0.5], 127); // Special case: wraparound 360<->0
    );

    prev_pov0 = pov0;
  );
);

// TODO: Add more tunings (realign pov_map array pointer (pov_map = deg + 17)).
// TODO: Don't interrupt notes with cancel_all_inputs() on state modifications.
// TODO: Support microtonal.
